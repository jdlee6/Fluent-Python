'''
Iterables, iterators, generators

lazily means one item at a time and on demand (iterator pattern)
yield keyword allows the construction of generators which work as iterators

generators fully implement the iterator interface
iterator - retrieves items from a collection, while a generator produce items "out of thin air"

Every collection in Python is iterable and iterators are used internally to support:
    for loops
    collection types construction and extension
    looping over text file lines by line
    list dict and set comprehensions
    tuple unpacking
    unpacking actual parameters with * in function calls 


iter(...) function makes sequences iterable
Sentence take #1: a sequence of words
'''
# # example - take a look at sentence.py - testing iteration on Sentence instance
# from Sec14_examples.sentence import Sentence

# # A sentence is created from a string
# s = Sentence('"The time has come," the Walrus said,')

# # note the output of __repr__ using . . . generated by reprlib.repr
# print(repr(s))
# # Sentence('"The time ha... Walrus said,')

# # Sentence instances iterable (we'll see why in a moment)
# for word in s:
#     print(word)
# # The
# # time
# # has
# # come
# # the
# # Walrus
# # said

# # Being iterable, Sentence objects can be used as input to build lists and other iterable types
# print(list(s))
# # ['The', 'time', 'has', 'come', 'the', 'Walrus', 'said']

# # This example implementation is different from all the others because it is ALSO a sequence due to __getitem__ and __len__ -- and because it is a sequence you can retrieve words by index
# print(s[0])
# # The
# print(s[5])
# # Walrus
# print(s[-1])
# # said

'''
Why sequences are iterable: the iter function

Whenever the interpreter needs to iterate over an object x, it automatically calls iter(x)
the iter built-in function:
    1. checks whether the object implements __iter__ and calls that to obtain an iterator
    2. if __iter__ NOT implemented, but __getitem__ IS implemented, Python creates an iterator that attempts to fetch items in order, starting from index 0 (zero);
    3. if that fails, Python raises a TypeError, saying that "'C' object is not iterable", where C is the class of the target object

*this is why any Python sequence is iterable because they ALL implement __getitem__. 
    -should also implement __iter__ because the special handling of __getitem__ exists for backward compatibility reasons

duck typing: object is considered iterable NOT ONLY with __iter__ but also __getitem__ as long as it accepts int keys starting from 0

goose typing (not as flexible): object is considered iterable if it implements the __iter__ method; no subclassing or registration is required because abc.Iterable implements the __subclasshook__

*most accurate way to check when an object is iterable is to call iter(x) and handle a TypeError exception if it isn't; more accurate than using isinstance(x, abc.Iterable) because iter(x) considers the __getitem__ method while abc.Iterable does NOT (look at the example below)
'''
# example
# class Foo:
#     def __iter__(self):
#         pass

# from collections import abc
# print(issubclass(Foo, abc.Iterable))
# # True

# f = Foo()
# print(isinstance(f, abc.Iterable))
# # True

# # Sentence does NOT pass because it is missing the __iter__ special method even though it is iterable in practice
# print(issubclass(Sentence, abc.Iterable))
# # False

# print(iter(s))
# # <iterator object at 0x7feb98ce0ac8>

# print(list(iter(s)))
# # ['The', 'time', 'has', 'come', 'the', 'Walrus', 'said']


'''
iterables vs. iterators

iterable 
    any object from which the iter built-in function can obtain an iterator. Objects implementing an __iter__ method returning an iterator are iterable. Sequences are ALWAYS iterables; so as are objects implementing a __getitem__ method which takes 0 based indexes

Python obtains iterators FROM iterables 
'''
# # example - string 'ABC' is the ITERABLE (iterator is behind the curtains)
# s = 'ABC'
# for char in s:
#     print(char)
# # A
# # B
# # C

# # example - with a while loop and iter()
# # build an iterator it from the iterable
# it = iter(s)
# while True:
#     try:
#         # repeatedly call next on the iterator to obtain the next item
#         print(next(it))
#     # iterator raises StopIteration when there are NO further items 
#     # StopIteration signals that the iterator is EXHAUSTED
#     except StopIteration:
#         # release the reference to it - the iterator object is discarded
#         del it
#         # break out of the loop
#         break
# # A
# # B
# # C

# # empty list because all the items are printed out
# print(list(it))
# # []

'''
standard interface for an iterator has TWO methods:
__next__ 
    returns the next available item, raising StopIteration when there are NO more items
__iter__
    returns self; this allows iterators to be used where an iterable is expected, for example, in a for loop

Iterator ABC implements __iter__ by doing return self which allows an iterator to be used wherever an iterable is required

**Use hasattr to check for both __iter__ and __next__ attributes instead (this is what the __subclasshook__ method does)**
**best way to check if an object x is an iterator is to call isinstance(x, abc.Iterator); Iterator.__subclasshook__ allows this test to work even if the class of x is NOT a real or virtual subclass of iterator
'''
# # example - abc.Iterator class
# # https://hg.python.org/cpython/file/3.4/Lib/_collections_abc.py#l93 
# class Iterator(Iterable):
#     __slots__ = ()

#     @abstractmethod
#     # next(it) --> returns the next item of the iterator
#     def __next__(self):
#         'Return the next item from the iterator. When exhausted, raise StopIteration'
#         raise StopIteration

#     def __iter__(self):
#         return self

#     @classmethod
#     def __subclasshook__(cls, C):
#         if cls is Iterator:
#             if (any("__next__" in B.__dict__ for B in C.__mro__) and
#                 any("__iter__" in B.__dict__ for B in C.__mro__)):
#                 return True
#         return NotImplemented

# example - Sentence class example - see how the iterator is built by iter() and consumed by next()
# from Sec14_examples.sentence import Sentence

# # Create a sentence s3 with 3 words
# s3 = Sentence('Pig and Pepper')

# # obtain an iterator from s3
# it = iter(s3)
# print(it)
# # <iterator object at 0x7f2e2a8cf940>

# # next(it) fetches the next word
# print(next(it))
# # Pig
# print(next(it))
# # and
# print(next(it))
# # Pepper
# # There are no more words so the iterator raises a StopIteration exception
# # print(next(it))
# # # Traceback . . .
# # # StopIteration

# # once exhausted, an iterator becomes useless
# print(list(it))
# # []

# # to go over the sentence again, a new iterator must be built
# print(list(iter(s3)))
# # ['Pig', 'and', 'Pepper']

''''
NO way to check whether there are remaining items, other than call next() and catch StopIteration
NOT possible to reset an iterator; if you need to start over, call iter() on iterable and NOT on the iter() on iterator itself

iterator
    any object that implements the __next__ no-argument method which returns the next item in a series or raises StopIteration when there are NO more items. Iterators also implement the __iter__ method so they are iterable as well


Sentence take #2: a classic iterator (standard)
Makes explict the relationship between the iterable collection and the iterator object

Look at the example below to see the crucial distinction between an iterable and an iterator and HOW they are connected
'''

# example - take a look at sentence_iter.py: Sentence implemented using the Iterator pattern


'''
Making Sentence an iterator: BAD IDEA

iterables: __iter__ NO __next__
iterators: __next__ and __iter__ (iterators' __iter__ should return self)

iterators are also iterable but iterables are NOT iterators

Iterator pattern (can not make the Sentence instance BOTH an itierable and iterator (anti-pattern)):
    -to access an aggregate object's contents without exposing its internal representation
    -to support multiple traversals of aggregate objects
        (Traversing just means to process every character in a string, usually from left end to right end.)
    -to provide a uniform interface for traversing different aggregate structures (that is, to support polymorphic iteration)

*must be possible to obtain multiple independent iterators from the same iterable instance and each iterator must keep its own internal state, so a proper implementation of the pattern requires each call to iter(my_iterable) to create a new, independent, iterator (This is why we NEED SentenceIterator class in our example)


Sentence take #3: Generator Function
Uses a generator function to replace the SentenceIterator class
'''

# example - look at sentence_gen.py: Sentence implemented using a generator function

'''
in the example before this, __iter__ called SentenceIterator constructor to build an iterator and return it; now in this example Sentence is a generator object that is built automatically when the __iter__ method is called because __iter__ is a generator function


How a generator function works

any function that has the "yield" keyword in its body IS a generator function: a function which, when called, returns a generator object
    generator function is a generator factory

*generator function builds a generator object which wraps the body of the function
**generators YIELD or PRODUCE values; calling a generator function RETURNS a generator; RETURN statement in the body of a generator function causes StopIteration to be raised by the generator object
'''
# example - simple function to demonstrate the behavior of generator

# # Any Python function that contains the yield keyword is a generator function
# def gen_123():
#     # Usually the body of a generator function has loop, but not necessarily; here I just repeat yield three times
#     yield 1
#     yield 2
#     yield 3

# # Looking closely, we see gen_123 is a function object
# print(gen_123)
# # <function gen_123 at 0x7f13559491e0>

# # When invoked, gen_123() returns a generator object
# print(gen_123())
# # <generator object gen_123 at 0x7f5a165314f8>

# # Generators are iterators that produce the values of the expressions passed to yield
# for i in gen_123():
#     print(i)
# # 1
# # 2
# # 3

# # for closer inspection, we assign the generator object to g
# g = gen_123()

# # since g is an iterator, calling next(g) fetches the next item produced by yield
# print(next(g))
# # 1
# print(next(g))
# # 2
# print(next(g))
# # 3

# # when the body of the function completes, the generator object raises a StopIteration
# print(next(g))
# # Traceback (most recent call last):
# # ...
# # StopIteration

# example - generator function which prints message when it runs

# # the generator function is defined like any function but uses YIELD
# def gen_AB():
#     print('start')
#     # the first implicit call to next() in the for loop will print 'start' and stop at the first yield, producing the value 'A"
#     yield 'A'
#     print('continue')
#     # the second implicit call to next() in the for loop will print 'continue' and stop at the second yield, producing the value 'B'
#     yield 'B'
#     # the third call to next() will print 'end.' and fall through the end of the function body causing the generator object to raise StopIteration
#     print('end.')

# # to iterate, the for machinery does the equivalent of g = iter(gen_AB()) to get a generator object, and then next(g) at each iteration
# for c in gen_AB():
#     # the loop block prints --> and the value returned by next(g). But this output will be seen only after the output of the print calls inside the generator function
#     print('-->', c)

# # the string 'start' appears as a result of print('start') in the generator function body
# # start

# # yield 'A' in the generator function body produces the value A consumer by the for loop, which gets assigned to the c variable and results in the output --> A
# # --> A

# # Iteration continues with a second call next(g), advancing the generator function body from yield 'A' to yield 'B'. The text continue is output because of the second print in the generator function body
# # continue

# # yield 'B' produces the value B consumed by the for loop, which gets assigned to the c loop variable so the loop prints --> B
# # --> B

# # iteration continues with a third call next(it), advancing to the end of the body of the function. the text end. appears in the ouput because of the third print in the generator function body
# # end.

# # when the generator function body runs to the END, the generator object raises StopIteration. The for loop machinery catches that exception and the loop terminates cleanly.


'''
Sentence take #4: a lazy implementation
*opposite of lazy is eager

Iterator interface is designed to be lazy: next(my_iterator) produces one item at a time
the examples above have NOT been lazy because the __init__ eagerly builds a list of ALL words in the text and binds them to the self.words attribute

re.finditer() is a lazy version of re.findall() and it returns a generator producing re.MatchObject instances on demand
    -saves memory for many matches 

*only produces the next word when it is needed instead of producing all of the words in __init__
'''

# example - take a look at sentence_gen2.py to see how generator expressions can make the code a lot shorter

'''
Sentence take #5: a generator expression
generator functions can be replaced by generator expressions

generator expression is a lazy version of a list comprehension: it doesn't EAGERLY build a list, but returns a generator that will LAZILY produce the items on demand
    -if a list comp is factory of lists; a generator exp. is factory of generators
'''
# example - the gen_AB generator function is used by a list comp, then by a generator expression

# this is the same gen_AB function from the previous example
def gen_AB():
    print('start')
    yield 'A'
    print('continue')
    yield 'B'
    print('end.')

# the list comprehension eagerly iterates over the items yielded by the generator object produced by calling gen_AB(): 'A' and 'B'. Note the output in the nex lines: start, continue, end
res1 = [x*3 for x in gen_AB()]
# start
# continue
# end.

# this for loop is iterating over the res1 list produced by the list comprehension
for i in res1:
    print('-->', i)
# --> AAA
# --> BBB

# the generator expression returns res2. The call to gen_AB() is made, but that call returns a generator which is NOT consumed here
res2 = (x*3 for x in gen_AB())
# res2 is a generator object
print(res2)
# <generator object <genexpr> at 0x7f0459e19930>

# Only when the for loop iterates over res2, the body of gen_AB actually executes. Each iteration of the for loop implicitly calls next(res2), advancing gen_AB to the next yield. Note the output of gen_AB with the output of the print in the for loop
for i in res2:
    print('-->', i)
# start
# --> AAA
# continue
# --> BBB
# end.

'''
a generator expression produces a generator and we can use it to further reduce the code in the Sentence class

take a look at sentence_genexp.py
generator expressions are syntactic sugar: they can be replaced by generator functions but sometimes are MORE convenient


Generator expressions: when to use them

Generator functions are much more flexible: you can code complex logic with multiple statements and can use them as coroutines (lets you have many seemingly simultaneous functions in a Python program; implemented as an extension to generators)

If the generator expression spans more than a couple lines, just code a generator function for the sake of readability
    generator functions have a name which means they can be reused


Another example: arithmetic progression generator
...
'''